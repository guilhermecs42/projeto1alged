		NOME E NÚMERO USP DOS INTEGRANTES DO GRUPO:

Cleyton Jose Rodrigues Macedo - 16821725
Giovanni Torres Bullo - 16869833
Guilherme Cavalcanti de Santana - 15456556

		ESTRUTURA GERAL DO PROJETO

Nós decidimos dividir o desenvolvimento em três etapas:
	- Criar estruturas de dados genéricas: pilha, fila e lista.
	- Criar TADs específicos: tratamento e paciente.
	- Criar o sistema (main.c) que integram esses dois tipos de TAD. 
	
Como a terceira etapa foi feita de forma independente e posterior às outras duas, algumas funções implementadas nas EDs não foram usadas no sistema final.
	
As estruturas de dados genéricas armazenam ponteiros para void, em vez de um TAD Item pré-definido. Para que as EDs possam executar suas funções, elas precisam executar as funções definidas pelo item que armazenam. Por exemplo, para carregar uma lista de pacientes de um arquivo, o TAD lista precisa carregar cada paciente individual, mesmo que o armazene com um void* genérico. Para isso, foi definida uma Dispatch Table no arquivo tabela_funcoes.h. Essa tabela armazena ponteiros para funções. Os TADs específicos (paciente e tratamento) possuem como variável estática (visível só no arquivo de implementação) uma instância dessa tabela preenchida com ponteiros para suas próprias funções, e possuem uma função que retorna o endereço dessa tabela. Cada TAD genérico, no momento de sua criação, recebe o endereço dessa tabela e o armazena em sua estrutura. Assim, as EDs genéricas conseguem guardar qualquer TAD específico que se queira (poderíamos criar um TAD Médico, TAD Hospital, etc), desde que as funções usadas por esses TADs específicos sejam fornecidas por meio de Dispatch Table no momento da criação da ED. As funções guardadas pela Dispatch Table são: apagar, imprimir, comparar, salvar, carregar e copiar. As funções apagar e imprimir são autoexplicativas. As funções de salvar e carregar serão explicadas no próximo parágrafo. A função comparar é utilizada para realizar buscas: ela faz a comparação de dois TADs específicos (por exemplo, dois pacientes), e seu output é 0 se eles forem iguais em algum sentido (os detalhes dependem da implementação). As EDs usam essa função para realizar buscas, comparando cada item armazenado com um item fictício que é usado como chave de busca. A função copiar é usada para retornar uma lista de resultados da busca, caso necessário.

Cada ED genérica e TAD específico possuem duas funções que trabalham em conjunto: salvar e carregar. A função salvar recebe ponteiro para uma ED/TAD que se deseja salvar em um arquivo. Ela começa escrevendo um cabeçalho para identificar o que está sendo salvo, e então começa a registrar as informações relevantes. Caso uma ED esteja sendo armazenada, ela irá chamar a função "salvar" dos itens que ela armazena, por meio da Dispatch Table. Por fim, um rodapé é escrito no arquivo, para determinar o fim do registro. A função carregar vai fazer o trabalho oposto: vai ler um arquivo e colocá-lo numa ED/TAD na memória. Para isso, a função precisa receber um arquivo com a formatação correta. O que define a formatação correta é a função "salvar" correspondente, que criou o cabeçalho e o rodapé. Assim como a função salvar, a função carregar pode precisar chamar funções carregar de outros TADs. Portanto, a escrita e leitura de arquivos é feita de forma "encapsulada", e as funções de diferentes TADs conseguem cooperar entre si.

A política de gerenciamento de memória adotada é que as EDs genéricas (pilha, fila, lista) se tornam 'donos' dos itens inseridos. Elas são, portanto, responsáveis por chamar a função apagar de cada item através da Dispatch Table.

O sistema propriamente dito (main.c) utiliza um arquivo especial para obter inputs do usuário: o entrada.h/entrada.c. O propósito desse arquivo é definir funções robustas e relativamente seguras para obter comandos, nomes e números do usuário do sistema. Essas funções possuem algumas proteções contra buffer overflow e entradas inválidas, mas não é 100% garantido que elas protegem contra todos os inputs maliciosos.
	
		DESCRIÇÃO DE CADA TAD

PILHA: É uma pilha encadeada de alocação dinâmica, como ensinada nas primeiras aulas da disciplina, mas que armazena ponteiros para void. Como as outras EDs e TADs, possui as funções imprimir, salvar e carregar, que utilizam a Dispatch Table (tabela_funcoes.h) para usar as funções dos itens que armazena. A função salvar escreve primeiro a base da lista, e por último o topo. Assim, a função carregar simplesmente empilha os elementos em ordem de leitura. A implementação encadeada e de alocação dinâmica foi preferida por permitir a maior genericidade de uso possível, o que é compatível com o nosso plano de desenvolvimento.
FILA: É uma fila encadeada de alocação dinâmica, como ensinada nas primeiras aulas da disciplina, mas que armazena ponteiros para void. Além das funções esperadas, possui a função fila_buscar, que retorna um elemento cuja comparação com a chave de busca resulta em 0 (função comparar). Novamente, a fila encadeada e com alocação dinâmica foi escolhida por ser genérica e reutilizável.
LISTA: é uma lista simplesmente encadeada com alocação dinâmica. Possui um ponteiro para o fim da lista, a fim de otimizar inserções no fim. Não é uma lista ordenada. Armazena ponteiros para void e possui duas funções de busca. Uma dessas funções retorna uma lista com cópias dos resultados da busca (por isso a Dispatch Table tem uma função de copiar). A outra função retorna o primeiro item compatível com a chave de busca.
TRATAMENTO: é um struct simples que guarda uma string de no máximo 100 caracteres: o procedimento/medicamento/tratamento em questão. Como é necessário, possui uma função get que retorna uma Dispatch Table com ponteiros para as suas funções. A função comparar retorna 0 caso dois tratamentos armazenem a exata mesma string.
PACIENTE: é um struct que guarda um inteiro (ID), array de char (nome), e uma pilha de tratamentos. Possui algumas funções que precisam ser explicadas: há duas funções para verificar se o histórico de tratamentos (pilha) está cheio ou vazio, com base no limite de 10 tratamentos; Há duas outras funções para adicionar um tratamento ou removê-lo da pilha; A função imprimir apenas exibe o ID e nome do paciente; A função consultar_histórico imprime a pilha de tratamentos; A função comparar retorna 0 se os dois pacientes comparadas tem o mesmo nome ou o mesmo ID; Há uma função para retornar o ID do paciente.

		SISTEMA PROPRIAMENTE DITO (main.c)
		
O Registro de Pacientes é um struct que armazena o próximo ID a ser inserido e uma lista de pacientes. Quando um paciente é inserido no Registro, o inteiro armazenado no struct é incrementado, preparando a inserção do próximo paciente. Decidimos implementar a atribuição de IDs dessa forma para não ocorrer a situação absurda de o atendente precisar tentar vários IDs diferentes até encontrar um disponível. O ID mínimo é 1. Caso um paciente seja retirado do registro (faleceu), ele é removido da lista e o seu ID permanece indisponível. Decidimos implementar dessa forma para não ocorrer possível mistura de informações entre os mortos e os vivos nos outros possíveis registros do hospital. Como o registro não é simplesmente uma lista de pacientes, mas sim um inteiro E uma lista de pacientes, foi necessário implementar funções carregar e salvar próprias para o registro. Vale destacar que como cada TAD paciente guarda a sua pilha de tratamentos, o arquivo de registro de pacientes contém todos tratamentos de todos os pacientes.

As funcionalidades da Fila de Espera estão implementadas de forma espalhada pelo código, pois ela é simplesmente uma fila. O tamanho máximo da fila é 50. Se a fila estiver cheia, não é mais possível inserir pacientes na fila de espera, mas ainda é possível registrá-los no sistema. É impossível inserir um paciente na fila de espera se ele já estiver na fila.

A primeira coisa que o usuário precisa fazer ao entrar no sistema é digitar os nomes dos arquivos onde estão armazenados o registro de pacientes e a fila de espera. Caso não haja arquivos, o usuário pode escolher começar do zero. Há verificações para saber se os arquivos existem e se eles compõem registros válidos. Após isso, ele entra no core loop do sistema: digitar um comando válido e prosseguir com as instruções. Ele pode digitar '0' se deseja cancelar a operação (nem sempre está disponível essa opção) e talvez precise digitar '1' para prosseguir com algumas instruções. Sempre que alguma operação for inválida ou ocorrer algum erro interno, o usuário é notificado. Ao sair do sistema digitando 0 no menu principal, as alterações feitas no registro e na fila são salvas em seus respectivos arquivos.
